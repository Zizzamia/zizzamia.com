/**
 *  A Lexer.
 *
 *  Use Lexer.feed (str) to input a string for it to break it down.
 *  Use Lexer.next () to get the next token.
 *  Use Lexer.peek () to see a future token without advancing in the stream.
 *
 *  This Lexer does NOT use regular expression but simple strings for speed.
 */
(function(){
  var Lexer;
  Lexer = (function(){
    /**
     *  Sort function for token sorting. Orders the array so that
     *  the first element in the next token in the string (aka, its
     *  position is the lowest one). In case of having two tokens
     *  at the same position - because they start the same - put first
     *  the longest one, so that, for exemple, == comes before =.
     *
     *  @param a: First Operand
     *  @param b: Second Operand
     *  @returns 1, 0 or -1
     */
    Lexer.displayName = 'Lexer';
    var __token_sort, prototype = Lexer.prototype, constructor = Lexer;
    __token_sort = (function(){
      function __token_sort(a, b){
        if (a.pos == -1) {
          return 1;
        }
        if (b.pos == -1) {
          return -1;
        }
        if (a.pos < b.pos) {
          return -1;
        }
        if (a.pos == b.pos) {
          if (a.tok.length > b.tok.length) {
            return -1;
          }
          if (a.tok.length < b.tok.length) {
            return 1;
          }
          return 0;
        }
        return 1;
      }
      return __token_sort;
    }());
    /**
     *
     */
    function Lexer(specs){
      var token, _res, _i, _ref, _len;
      this.input = null;
      this.position = 0;
      this.lineno = 0;
      _res = [];
      for (_i = 0, _len = (_ref = specs.tokens).length; _i < _len; ++_i) {
        token = _ref[_i];
        _res.push({
          tok: token,
          pos: -1
        });
      }
      this.tokens_order = _res;
    }
    prototype.computeTokenPositions = (function(){
      function computeTokenPositions(){
        var token, _i, _ref, _len;
        for (_i = 0, _len = (_ref = this.tokens_order).length; _i < _len; ++_i) {
          token = _ref[_i];
          token.pos = this.input.indexOf(token.tok, this.position);
        }
        return this.tokens_order.sort(__token_sort);
      }
      return computeTokenPositions;
    }());
    prototype.feed = (function(){
      function feed(str){
        this.input = str;
        this.position = 0;
        this.lineno = 0;
        return this.computeTokenPositions();
      }
      return feed;
    }());
    prototype.advance = (function(){
      function advance(to_position){
        var res;
        res = this.input.slice(this.position, to_position);
        this.position = to_position;
        return res;
      }
      return advance;
    }());
    prototype.advanceCurrentToken = (function(){
      function advanceCurrentToken(){
        var next_token, res;
        next_token = this.tokens_order[0];
        if (next_token.tok == "\n") {
          this.lineno += 1;
        }
        res = this.advance(this.position + next_token.tok.length);
        this.computeTokenPositions();
        return res;
      }
      return advanceCurrentToken;
    }());
    /**
     *  Return the next token in the input stream.
     */
    prototype.next = (function(){
      function next(){
        var result, next_token;
        if (this.input == null) {
          throw {
            message: "Lexer has not been fed an input."
          };
        }
        if (this._cached_next !== undefined) {
          result = this._cached_next;
          this._cached_next = undefined;
          return result;
        }
        if (this.position >= this.input.length) {
          return null;
        }
        next_token = this.tokens_order[0];
        if (next_token.pos == -1) {
          return this.advance(this.input.length);
        }
        if (next_token.pos == this.position) {
          return this.advanceCurrentToken();
        } else {
          return this.advance(next_token.pos);
        }
      }
      return next;
    }());
    /**
     *  Return the next token in the input stream, and cache its result, so that
     *  every subsequents call to peek and the next call to next() return the same token
     */
    prototype.peek = (function(){
      function peek(){
        if (this._cached_next == undefined) {
          this._cached_next = this.next();
        }
        return this._cached_next;
      }
      return peek;
    }());
    return Lexer;
  }());
  exports.Lexer = Lexer;
}).call(this);
