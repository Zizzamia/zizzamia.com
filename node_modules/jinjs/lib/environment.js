(function(){
  var Parser, render_template, watchFile, readFileSync, join, dirname, Environment, BasicFileEnvironment, _ref;
  Parser = require('./parser').Parser;
  render_template = require('./module_template').render;
  _ref = require('fs'), watchFile = _ref.watchFile, readFileSync = _ref.readFileSync;
  _ref = require('path'), join = _ref.join, dirname = _ref.dirname;
  /**
   *  A very basic environment.
   */
  Environment = (function(){
    Environment.displayName = 'Environment';
    var $evalTemplateObject, prototype = Environment.prototype, constructor = Environment;
    $evalTemplateObject = function(t, env){
      var environment;
      environment = env;
      return eval(t);
    };
    function Environment(_arg){
      var _ref, _ref2;
      _ref = _arg != null
        ? _arg
        : {}, this.utils = (_ref2 = _ref.utils) != null
        ? _ref2
        : require("./utils"), this.filters = (_ref2 = _ref.filters) != null
        ? _ref2
        : require("./filters"), this.parser = (_ref2 = _ref.parser) != null
        ? _ref2
        : new Parser(), this.pre_compile_func = (_ref2 = _ref.pre_compile_func) != null ? _ref2 : "", this.require_exp = (_ref2 = _ref.require_exp) != null ? _ref2 : 'require';
    }
    prototype.getTemplateFromString = (function(){
      function getTemplateFromString(str){
        var exports, compiled;
        try {
          exports = {};
          compiled = this.getTemplateSourceFromString(str);
          eval(compiled);
          return exports;
        } catch (e) {
          if (e instanceof SyntaxError) {
            console.log(compiled);
          }
          throw e;
        }
      }
      return getTemplateFromString;
    }());
    prototype.getTemplateSourceFromString = (function(){
      function getTemplateSourceFromString(str){
        var ast, opts, compilation_ctx, body, _ref;
        if (this.pre_compile_func) {
          str = this.pre_compile_func(str);
        }
        ast = this.parser.parse(str, compilation_ctx);
        opts = {
          __indent__: 1,
          utils: this.utils,
          filters: this.filters
        };
        compilation_ctx = {
          filters_used: {}
        };
        compilation_ctx.filters = this.filters;
        compilation_ctx.utils = this.utils;
        body = ast.compile(opts, compilation_ctx);
        _ref = __import(opts, compilation_ctx);
        _ref.body = body;
        _ref.require_exp = this.require_exp;
        return render_template(opts);
      }
      return getTemplateSourceFromString;
    }());
    return Environment;
  }());
  /**
   *  A basic file compilation environment. It has no notion of template
   *  directories to look in ; it expects getTemplate() to be provided with
   *  an absolute path to its template.
   *
   *  Inside templates, templates can be called by relative paths however.
   *
   *  If a file doesn't exist, this environment will just crash and burn, as
   *  it makes no checks whatsoever.
   */
  BasicFileEnvironment = (function(_super){
    /**
     *  Constructor.
     */
    BasicFileEnvironment.displayName = 'BasicFileEnvironment';
    var prototype = __extends(BasicFileEnvironment, _super).prototype, constructor = BasicFileEnvironment;
    function BasicFileEnvironment(specs){
      specs.require_exp = "__load_template";
      BasicFileEnvironment.superclass.apply(this, arguments);
      this.cache = {};
      this.tracked = {};
      this.deps = {};
    }
    /**
     *  Invalidate the files that depend on the template at path.
     *  @param path: The base template.
     */
    prototype.invalidateDeps = function(path){
      var file, deps, _ref, _ref2;
      for (file in _ref = this.deps) {
        deps = _ref[file];
        if (path in deps) {
          delete this.cache[file];
          this.invalidateDeps(file);
        }
      }
      return _ref2 = (_ref = this.deps)[path], delete _ref[path], _ref2;
    };
    /**
     *  @param path: The path to monitor for changes.
     */
    prototype.trackFile = function(path){
      var _this = this;
      if (!(path in this.tracked)) {
        this.tracked[path] = true;
        return watchFile(path, function(curr, prev){
          if (curr.mtime > prev.mtime) {
            delete _this.cache[path];
          }
          return _this.invalidateDeps(path);
        });
      }
    };
    /**
     *  @param  path: An absolute path.
     *  @throws Error if the path does not exist.
     */
    prototype.getTemplate = function(path){
      var result;
      if (path in this.cache) {
        return this.cache[path];
      }
      result = readFileSync(path, 'utf-8');
      result = this.getTemplateFromString(result, {
        filename: path,
        root: dirname(path)
      });
      this.cache[path] = result;
      return result;
    };
    /**
     *  @param str: The text contents of the template.
     *  @param opts: An object containing at least "filename" as the path
     *      to the template, and "root" as its basedir.
     */
    prototype.getTemplateFromString = function(str, opts){
      var exports, compiled, __filename, __dirname, __load_template, _this = this;
      __filename = opts.filename;
      __dirname = opts.root;
      this.trackFile(__filename);
      this.deps[__filename] = {};
      __load_template = function(path){
        if (path[0] != '/') {
          path = join(__dirname, path);
        }
        _this.deps[__filename][path] = true;
        return _this.getTemplate(path);
      };
      try {
        exports = {};
        compiled = this.getTemplateSourceFromString(str);
        eval(compiled);
        return exports;
      } catch (e) {
        if (e instanceof SyntaxError) {
          console.log(compiled);
        }
        throw e;
      }
    };
    return BasicFileEnvironment;
  }(Environment));
  exports.defaultEnvironment = new Environment({
    filters: require("../lib/filters"),
    utils: require("../lib/utils")
  });
  exports.Environment = Environment;
  exports.BasicFileEnvironment = BasicFileEnvironment;
  function __import(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function __extends(sub, sup){
    function ctor(){} ctor.prototype = (sub.superclass = sup).prototype;
    (sub.prototype = new ctor).constructor = sub;
    if (typeof sup.extended == 'function') sup.extended(sub);
    return sub;
  }
}).call(this);
