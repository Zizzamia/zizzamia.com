(function(){
  var Lexer, NodeComment, NodeList, NodePrint, default_nodes, tk_tag_open, tk_tag_open_spc, tk_tag_close, tk_tag_close_spc, tk_tag_single, tk_comment_open, tk_comment_open_spc, tk_comment_close, tk_comment_close_spc, tk_comment_single, tk_print_open, tk_print_close, tk_new_line, default_tokens, Parser, _ref, _tag_search;
  Lexer = require('./lexer').Lexer;
  _ref = require('./nodes'), NodeComment = _ref.NodeComment, NodeList = _ref.NodeList, NodePrint = _ref.NodePrint, default_nodes = _ref.default_nodes;
  tk_tag_open = "{%";
  tk_tag_open_spc = "{%-";
  tk_tag_close = "%}";
  tk_tag_close_spc = "-%}";
  tk_tag_single = "%";
  tk_comment_open = "{#";
  tk_comment_open_spc = "{#-";
  tk_comment_close = "#}";
  tk_comment_close_spc = "-#}";
  tk_comment_single = "#";
  tk_print_open = "{{";
  tk_print_close = "}}";
  tk_new_line = "\n";
  default_tokens = [tk_tag_open, tk_tag_open_spc, tk_tag_close, tk_tag_close_spc, tk_comment_open, tk_comment_open_spc, tk_comment_close, tk_comment_close_spc, tk_print_open, tk_print_close, tk_new_line];
  /**
   *  @param str A string
   *  @returns    A trimmed string, without leading nor ending spaces.
   */
  function trim(str){
    if (str === null) {
      return null;
    }
    return str.replace(/^\s+/g, '').replace(/\s+$/g, '');
  }
  _tag_search = /\s*([a-zA-Z][-a-zA-Z0-9_]*)\s+((.|\n)*)/m;
  /**
   *  @param stmt The contents between {% and %}
   *  @returns    An object containing the tag portion and the contents.
   */
  function parse_tag(stmt){
    var m, _ref;
    m = _tag_search.exec(stmt);
    return [m[1], (_ref = m[2]) != null ? _ref : ""];
  }
  function remove_spaces(str){
    var i, _ref;
    i = 0;
    while ((_ref = str[i]) === ' ' || _ref === "\t") {
      i += 1;
    }
    return [str.substr(0, i), str.substr(i)];
  }
  /**
   *  The parser is used to build a node tree : this node tree will present a compile () method
   *  that generates javascript code ready to be compiled.
   */
  Parser = (function(){
    Parser.displayName = 'Parser';
    var prototype = Parser.prototype, constructor = Parser;
    function Parser(specs){
      var _ref;
      specs == null && (specs = {});
      this.nodes = (_ref = specs.nodes) != null ? _ref : default_nodes;
      this.lexer = new Lexer({
        tokens: default_tokens
      });
      this.root = NodeList();
      this.trim_blocks = (_ref = specs.trim_blocks) != null ? _ref : true;
      this._discard_next_space = false;
      this._discard_next_newline = false;
      this._cached_next = null;
    }
    prototype._nextToken = (function(){
      function _nextToken(){
        var acc, spaces, tok, _ref;
        if (this._cached_next != null) {
          this.current_token = this._cached_next;
          this._cached_next = null;
          return;
        }
        acc = '';
        do {
          this.current_token = this.lexer.next();
          if (this.current_token === tk_new_line) {
            acc += this.current_token;
            this.current_token = '';
          } else if (this.current_token != null) {
            _ref = remove_spaces(this.current_token), spaces = _ref[0], tok = _ref[1];
            acc += spaces;
            this.current_token = tok;
          }
        } while (this.current_token === '' && this.current_token !== null);
        if (acc === '' && this.current_token === null) {
          return;
        }
        if (this._discard_next_space || ((_ref = this.current_token) === tk_tag_open_spc || _ref === tk_comment_open_spc)) {
          this._discard_next_space = false;
          return;
        }
        if ((_ref = this.current_token) === tk_comment_close_spc || _ref === tk_tag_close_spc) {
          this._discard_next_space = true;
        }
        if (acc) {
          this._cached_next = this.current_token;
          return this.current_token = acc;
        }
      }
      return _nextToken;
    }());
    prototype.nextToken = (function(){
      function nextToken(){
        var i, _ref, _to, _ref2;
        this._nextToken();
        if (this.current_token == null) {
          return;
        }
        _ref = this.current_token;
        if (this._discard_next_newline) {
          for (i = 0, _to = _ref.length - 1; i <= _to; ++i) {
            if (_ref[i] == '\n') {
              this.current_token = _ref.substr(i + 1);
              break;
            }
          }
          if (!this.current_token) {
            this.nextToken();
            return;
          }
          this._discard_next_newline = false;
        }
        if (this.trim_blocks && ((_ref2 = this.current_token) === tk_comment_close || _ref2 === tk_tag_close)) {
          return this._discard_next_newline = true;
        }
      }
      return nextToken;
    }());
    /**
     *  Parse comments in the input.
     *  @return nothing ! We ditch everything inside.
     */
    prototype.parseComment = (function(){
      function parseComment(){
        var balance, comment;
        balance = 1;
        comment = "";
        do {
          this.nextToken();
          if (this.current_token == tk_comment_close || this.current_token == tk_comment_close_spc) {
            balance -= 1;
            continue;
          }
          if (this.current_token == tk_comment_open || this.current_token == tk_comment_open_spc) {
            balance += 1;
            continue;
          }
          comment += this.current_token;
        } while (this.current_token != null && balance > 0);
        if (balance != 0) {
          throw new Error("Unclosed Comment at line " + _lexer.lineno);
        }
      }
      return parseComment;
    }());
    /**
     *  Parse a print statement. Usually delimited by {{ and }}
     *  The insides of the print statement are in turn parsed to escape
     *  variables and filters with the ctx. and env.filters. prefix respectively.
     *
     *  @return a PrintNode
     */
    prototype.parsePrintStatement = (function(){
      function parsePrintStatement(){
        var statement;
        statement = "";
        do {
          this.current_token = this.lexer.next();
          if (this.current_token && this.current_token != tk_print_close) {
            statement += this.current_token;
          }
        } while (this.current_token != null && this.current_token != tk_print_close);
        if (this.current_token === null) {
          throw new Error("Waiting for '" + tk_print_close + "' at line " + this.lexer.lineno);
        }
        return new NodePrint({
          contents: trim(statement)
        });
      }
      return parsePrintStatement;
    }());
    /**
     *
     */
    prototype.parseTag = (function(){
      function parseTag(waiting_for){
        var tag_contents, name, contents, stop_clause, until_clause, inside_clause, child_node, tag, inside_name, inside_contents, inside_cls, inside_tag, _ref;
        tag_contents = "";
        this.nextToken();
        while (this.current_token != null && this.current_token != tk_tag_close && this.current_token != tk_tag_close_spc) {
          tag_contents += this.current_token;
          this.nextToken();
        }
        if (this.current_token === null) {
          throw new Error("Waiting for '" + tk_tag_close + "' on line " + this.lexer.lineno);
        }
        _ref = parse_tag(tag_contents), name = _ref[0], contents = _ref[1];
        if (name in waiting_for) {
          this.last_tag = [name, contents];
          return;
        }
        if (!this.nodes[name]) {
          throw new Error("Unexpected tag : '" + name + "' at line " + this.lexer.lineno);
        }
        stop_clause = {};
        until_clause = this.nodes[name]['until'];
        stop_clause[until_clause] = true;
        inside_clause = this.nodes[name]['inside'];
        __import(stop_clause, inside_clause);
        if (until_clause == "__endfile__") {
          child_node = this.parseLevel();
        } else if (until_clause) {
          child_node = this.parseLevel(stop_clause);
        }
        tag = new this.nodes[name]({
          name: trim(name),
          contents: trim(contents),
          child_node: child_node
        });
        if (!until_clause) {
          return tag;
        }
        while (this.last_tag != null && this.last_tag[0] != until_clause) {
          _ref = [this.last_tag[0], this.last_tag[1]], inside_name = _ref[0], inside_contents = _ref[1];
          inside_cls = this.nodes[name].inside[inside_name];
          inside_clause = inside_cls['inside'];
          stop_clause = (_ref = __import((_ref = {}, _ref[until_clause + ""] = true, _ref), inside_clause)) != null
            ? _ref
            : {};
          inside_tag = this.parseLevel(stop_clause);
          tag.push(new inside_cls({
            name: inside_name,
            contents: inside_contents,
            child_node: inside_tag
          }));
        }
        return tag;
      }
      return parseTag;
    }());
    /**
     *  Parse the input file.
     *  @return the root NodeList
     */
    prototype.parseLevel = (function(){
      function parseLevel(waiting_for){
        var result, tag;
        waiting_for == null && (waiting_for = {});
        if (waiting_for != null && !typeof waiting_for == 'object') {
          waiting_for = {
            waiting_for: true
          };
        }
        result = new NodeList();
        for (;;) {
          this.nextToken();
          if (!this.current_token) {
            break;
          }
          if (this.current_token == tk_tag_open || this.current_token == tk_tag_open_spc) {
            tag = this.parseTag(waiting_for);
            if (!tag) {
              return result;
            }
            result.push(tag);
            continue;
          }
          if (this.current_token == tk_print_open) {
            result.push(this.parsePrintStatement());
            continue;
          }
          if (this.current_token == tk_comment_open || this.current_token == tk_comment_open_spc) {
            result.push(this.parseComment());
            continue;
          }
          result.push(this.current_token);
        }
        return result;
      }
      return parseLevel;
    }());
    /**
     *  Holder function for _parse_global
     *  @return _parse_global's result
     */
    prototype.parse = (function(){
      function parse(str){
        this.lexer.feed(str);
        this.current = this.root;
        this.current_token = "";
        return this.parseLevel();
      }
      return parse;
    }());
    return Parser;
  }());
  exports.Parser = Parser;
  exports.default_tokens = default_tokens;
  function __import(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
